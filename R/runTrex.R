#' Main Trex interface
#' 
#' Use this to run the Trex algorithm to return latent vectors in 
#' the form of a matrix or if you prefer, a maTrex.
#' 
#' @examples
#' trex_values <- maTrex(trex_example, 
#'                         chains = "TRA",
#'                         AA.properties = "AF")
#'                         
#' @param sc Single Cell Object in Seurat or SingleCell Experiment format
#' @param chains TRA or TRB
#' @param AA.properties Amino acid properties to use for distance calculation: 
#' "AF" = Atchley factors, "KF" = Kidera factors, "both" = AF and KF.
#' 
#' @export
#' @importFrom SeuratObject CreateDimReducObject
#' 
#' @return Trex encodedd values from the autoencoder
maTrex <- function(sc, 
                    chains = "TRB", 
                    AA.properties = "AF") {
    TCR <- getTCR(sc, chains)
    if (AA.properties %in% c("AF", "KF", "both", "all")) {
        print("Calculating the Amino Acid Properties...")
        reduction <- aaProperty(TCR, AA.properties)
    }
    return(reduction)
}

#' Trex single cell calculation
#'
#'Run Trex algorithm with Seurat or SingleCellExperiment pipelines
#'
#' @examples
#' trex_example <- runTrex(trex_example, 
#'                         AA.properties = "AF", 
#'                         reduction.name = "Trex.AF")
#'                         
#' @param sc Single Cell Object in Seurat or SingleCell Experiment format
#' @param chains TRA or TRB
#' @param AA.properties Amino acid properties to use for distance calculation: 
#' "AF" = Atchley factors, "KF" = Kidera factors, or "both"
#' @param reduction.name Keyword to save Trex reduction. Useful if you want
#' to try Trex with multiple parameters 
#' @export
#' @return Seurat or SingleCellExperiment object with Trex dimensions placed 
#' into the dimensional reduction slot. 
#' 
runTrex <- function(sc, 
                    chains = "TRB", 
                    AA.properties = "AF",
                    reduction.name = "Trex") {

    cells.chains <- rownames(sc[[]][!is.na(sc[["CTaa"]]),])
    sc <- subset(sc, cells = cells.chains)
    reduction <- maTrex(sc,
                        chains, 
                        AA.properties)
    TCR <- getTCR(sc, chains)
    sc <- adding.DR(sc, reduction, reduction.name)
    return(sc)
}

#' Remove TCR genes from variable gene results
#'
#'Most single-cell workflows use highly-expressed and highly-variable
#'genes for the initial calculation of PCA and subsequent dimensional
#'reduction. This function will remove the TCR genes from the variable
#'features in the Seurat object or from a vector generated by
#'the Bioconductor scran workflow. 
#'
#' @examples
#' x <- trex_example
#' x <- quietTCRgenes(x)
#' 
#' @param sc Single Cell Object in Seurat format or vector of variable genes to use in reduction
#' @export
#' @return Seurat object or vector list with TCR genes removed.
quietTCRgenes <- function(sc) {
    unwanted_genes <- "TRBV*|^TRBD*|^TRBJ*|^TRDV*|^TRDD*|^TRDJ*|^TRAV*|^TRAJ*|^TRGV*|^TRGJ*"
    if (inherits(x=sc, what ="Seurat")) {
        unwanted_genes <- grep(pattern = unwanted_genes, x = sc[["RNA"]]@var.features, value = TRUE)
        sc[["RNA"]]@var.features <- sc[["RNA"]]@var.features[sc[["RNA"]]@var.features %!in% unwanted_genes]
    } else {
        #Bioconductor scran pipelines uses vector of variable genes for DR
        unwanted_genes <- grep(pattern = unwanted_genes, x = sc, value = TRUE)
        sc <- sc[sc %!in% unwanted_genes]
    }
    return(sc)
}

#' Cluster clones using the Trex dimensional reductions
#' 
#' Use this to return clusters for clonotypes based on 
#' the \link[bluster]{bluster} clustering parameters.
#' 
#' @examples
#' \dontrun{
#' sc <- clonalCommunity(sc, 
#'                       reduction.name = NULL, 
#'                       cluster.parameter = KNNGraphParam())
#' }
#' @param sc Single Cell Object in Seurat or SingleCell Experiment format. In addition, the outputs of distReduction()
#' and aaReduction() can be used.
#' @param reduction.name Name of the dimensional reduction output from runTrex()
#' @param cluster.parameter The community detection algorithm in \link[bluster]{bluster}
#' @param ... For the generic, further arguments to pass to specific methods.
#' @importFrom bluster clusterRows NNGraphParam HclustParam KmeansParam KNNGraphParam PamParam SNNGraphParam SomParam DbscanParam
#' @importFrom igraph simplify spectrum graph_from_edgelist E `E<-`
#' @importFrom SingleCellExperiment reducedDim
#' @export
#' @return Single-Cell Object with trex.clusters in the meta.data
clonalCommunity <- function(sc, 
                            reduction.name = NULL, 
                            cluster.parameter=KNNGraphParam(k=30, ...), 
                            ...) {
    if (inherits(x=sc, what ="Seurat")) { 
        dim.red <- sc[[reduction.name]] 
        dim.red <- dim.red@cell.embeddings
    } else if (inherits(x=sc, what ="SingleCellExperiment")){
        dim.red <- reducedDim(sc, reduction.name)
    } else {
        if(inherits(x=sc, what ="dist")) {
            mat <- sc
            #mat[is.na(mat)] <- 0
            dimension <- attr(mat, "Size")
            edge <- NULL
            for (j in seq_len(dimension)[-1]) {
                row <- dist.convert(mat,j)
                tmp.edge <- data.frame("from" = j, "to" = seq_len(j)[-j], weight = row)
                edge <- rbind(edge, tmp.edge)
            }
            edge <- na.omit(edge)
            g <- graph.edgelist(as.matrix(edge[,c(1,2)]), directed = FALSE)
            E(g)$weights <- edge$weight
            g <- simplify(g)
            eigen <- spectrum(g, 
                              which = list(howmany = 30), 
                              algorithm = "arpack")
            dim.red <- eigen$vectors
        } else {
            dim.red <- sc
        }
    }
    clusters <- suppressWarnings(clusterRows(dim.red, BLUSPARAM=cluster.parameter))
    clus.df <- data.frame("trex.clusters" = paste0("trex.", clusters))
    if (inherits(x=sc, what ="Seurat") | inherits(x=sc, what ="SingleCellExperiment")) {
        rownames(clus.df) <- rownames(dim.red)
        sc <- add.meta.data(sc, clus.df, colnames(clus.df))
        return(sc)
    } 
    return(clus.df)
    
}
