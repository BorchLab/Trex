meta$enrichment.groupings[which(meta$tfh_clusters %in% c(8))] <- "C8"
meta <- meta[which(!is.na(meta[,"enrichment.groupings"])),]
master.df <- merge(ES2, meta, by = 0)
ES2 <- ES[rownames(ES) %in% rownames(meta[which(!is.na(meta[,"enrichment.groupings"])),]),]
variances <- apply(ES2, 2, var)
ES2 <- ES2[,-which(variances == 0)]
master.df <- merge(ES2, meta, by = 0)
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(all_of(gene.sets), median)) %>%
as.data.frame()
library(dplyr)
library(ggpointdensity)
master.df <- merge(ES2, meta, by = 0)
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(all_of(gene.sets), median)) %>%
as.data.frame()
library(tidyr)
master.df <- merge(ES2, meta, by = 0)
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(all_of(gene.sets), median)) %>%
as.data.frame()
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(gene.sets, median)) %>%
as.data.frame()
gene.sets <- colnames(ES)
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(gene.sets, median)) %>%
as.data.frame()
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(all_of(gene.sets), median)) %>%
as.data.frame()
summary.df <- master.df %>%
group_by(enrichment.groupings)
View(summary.df)
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(all_of(gene.sets), median)) %>%
as.data.frame()
meta <- tfh[[]]
meta$enrichment.groupings <- NA
meta$enrichment.groupings[which(meta$tfh_clusters %in% c(1,2))] <- "Memory.TFH"
meta$enrichment.groupings[which(meta$tfh_clusters %in% c(0,3))] <- "GC.TFH"
meta$enrichment.groupings[which(meta$tfh_clusters %in% c(7))] <- "C7"
meta$enrichment.groupings[which(meta$tfh_clusters %in% c(8))] <- "C8"
meta <- meta[which(!is.na(meta[,"enrichment.groupings"])),]
ES2 <- ES[rownames(ES) %in% rownames(meta[which(!is.na(meta[,"enrichment.groupings"])),]),]
variances <- apply(ES2, 2, var)
ES2 <- ES2[,-which(variances == 0)]
master.df <- merge(ES2, meta, by = 0)
master.df <- merge(ES2, meta, by = 0)
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(all_of(gene.sets), median)) %>%
as.data.frame()
master.df[,"enrichment.groupings"]
gene.sets
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(all_of(gene.sets), median))
gene.sets <- colnames(ES2)
summary.df <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(all_of(gene.sets), median)) %>%
as.data.frame()
summary.df[,2:ncol(summary.df)] <- scale(summary.df[,2:ncol(summary.df)])
summary.df <- reshape::melt(summary.df, id.vars = c("enrichment.groupings"))
summary.tp <- master.df %>%
group_by(enrichment.groupings, timepoint) %>%
summarize(across(gene.sets, median)) %>%
as.data.frame()
summary.tp <- reshape::melt(summary.tp, id.vars = c("enrichment.groupings", "timepoint"))
paths <- c("REACTOME_CELL_CYCLE_UCell", "REACTOME_CYTOKINE_SIGNALING_IN_IMMUNE_SYSTEM_UCell", "REACTOME_TRANSCRIPTIONAL_REGULATION_BY_RUNX2_UCell", "KEGG_OXIDATIVE_PHOSPHORYLATION_UCell","HALLMARK_INFLAMMATORY_RESPONSE_UCell", "HALLMARK_TNFA_SIGNALING_VIA_NFKB_UCell", "KEGG_MAPK_SIGNALING_PATHWAY_UCell", "BIOCARTA_CXCR4_PATHWAY_UCell", "REACTOME_TCR_SIGNALING_UCell")
test <- summary.df[summary.df$variable %in% paths,]
ggplot(test, aes(x = enrichment.groupings, y=variable)) +
geom_tile(aes(fill = value), color = "black") +
scale_fill_distiller(palette = "RdYlBu") +
scale_color_manual(values = c("#e21f26", "#faab50", "#3b8abe", "#85c669")) +
theme_classic()
library(ggplot2)
test <- summary.df[summary.df$variable %in% paths,]
ggplot(test, aes(x = enrichment.groupings, y=variable)) +
geom_tile(aes(fill = value), color = "black") +
scale_fill_distiller(palette = "RdYlBu") +
scale_color_manual(values = c("#e21f26", "#faab50", "#3b8abe", "#85c669")) +
theme_classic()
summary.tp <- master.df %>%
group_by(enrichment.groupings, timepoint) %>%
summarize(across(gene.sets, median)) %>%
as.data.frame()
View(summary.tp)
pheatmap::pheatmap(summary.tp[,3:ncol(summary.tp)])
pheatmap::pheatmap(t(summary.tp[,3:ncol(summary.tp)]))
pheatmap::pheatmap(t(summary.tp[,colnames(tp) %in% paths]))
pheatmap::pheatmap(t(summary.tp[,colnames(summary.tp) %in% paths]))
View(summary.tp)
summary.tp <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(gene.sets, median)) %>%
as.data.frame()
pheatmap::pheatmap(t(summary.tp[,colnames(summary.tp) %in% paths]),)
df <- t(summary.tp[,colnames(summary.tp) %in% paths])
View(df)
normalize <- function(x){
(x- min(x)) /(max(x)-min(x))
}
for (i in seq_len(nrow(df))) {
df[,i] <- normalize(df[i,])
}
for (i in seq_len(nrow(df))) {
df[i,] <- normalize(df[i,])
}
pheatmap::pheatmap()
pheatmap::pheatmap(df)
summary.tp <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(gene.sets, median)) %>%
as.data.frame()
View(summary.tp)
pheatmap::pheatmap(df)
x <- data.frame(colnames(ES2))
View(x)
paths <- c("REACTOME_CELL_CYCLE_UCell",
"REACTOME_PD_1_SIGNALING_UCell",
"BIOCARTA_MAPK_PATHWAY_UCell",
"REACTOME_INTERLEUKIN_1_SIGNALING_UCell",
"REACTOME_REGULATION_OF_RUNX2_EXPRESSION_AND_ACTIVITY_UCell",
"REACTOME_THE_CITRIC_ACID_TCA_CYCLE_AND_RESPIRATORY_ELECTRON_TRANSPORT_UCell", "HALLMARK_OXIDATIVE_PHOSPHORYLATION_UCell",
"REACTOME_CYTOKINE_SIGNALING_IN_IMMUNE_SYSTEM_UCell",
"KEGG_TOLL_LIKE_RECEPTOR_SIGNALING_PATHWAY_UCell",
"REACTOME_TRANSCRIPTIONAL_REGULATION_BY_RUNX2_UCell", "KEGG_OXIDATIVE_PHOSPHORYLATION_UCell",
"HALLMARK_INFLAMMATORY_RESPONSE_UCell",
"HALLMARK_TNFA_SIGNALING_VIA_NFKB_UCell",
"KEGG_MAPK_SIGNALING_PATHWAY_UCell",
"BIOCARTA_CXCR4_PATHWAY_UCell",
"REACTOME_TCR_SIGNALING_UCell",
"REACTOME_SIGNALING_BY_INTERLEUKINS_UCell")
paths <- unique(c("REACTOME_CELL_CYCLE_UCell",
"REACTOME_PD_1_SIGNALING_UCell",
"BIOCARTA_MAPK_PATHWAY_UCell",
"REACTOME_INTERLEUKIN_1_SIGNALING_UCell",
"REACTOME_REGULATION_OF_RUNX2_EXPRESSION_AND_ACTIVITY_UCell",
"REACTOME_THE_CITRIC_ACID_TCA_CYCLE_AND_RESPIRATORY_ELECTRON_TRANSPORT_UCell", "HALLMARK_OXIDATIVE_PHOSPHORYLATION_UCell",
"REACTOME_CYTOKINE_SIGNALING_IN_IMMUNE_SYSTEM_UCell",
"KEGG_TOLL_LIKE_RECEPTOR_SIGNALING_PATHWAY_UCell",
"REACTOME_TRANSCRIPTIONAL_REGULATION_BY_RUNX2_UCell", "KEGG_OXIDATIVE_PHOSPHORYLATION_UCell",
"HALLMARK_INFLAMMATORY_RESPONSE_UCell",
"HALLMARK_TNFA_SIGNALING_VIA_NFKB_UCell",
"KEGG_MAPK_SIGNALING_PATHWAY_UCell",
"BIOCARTA_CXCR4_PATHWAY_UCell",
"REACTOME_TCR_SIGNALING_UCell",
"REACTOME_SIGNALING_BY_INTERLEUKINS_UCell"))
summary.tp <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(gene.sets, median)) %>%
as.data.frame()
df <- t(summary.tp[,colnames(summary.tp) %in% paths])
for (i in seq_len(nrow(df))) {
df[i,] <- normalize(df[i,])
}
pheatmap::pheatmap(df)
View(df)
row.names(df) <- NULL
pheatmap::pheatmap(df)
df <- t(summary.tp[,colnames(summary.tp) %in% paths])
for (i in seq_len(nrow(df))) {
df[i,] <- normalize(df[i,])
}
row.names(df) <- NULL
summary.tp <- master.df %>%
group_by(enrichment.groupings) %>%
summarize(across(gene.sets, median)) %>%
as.data.frame()
df <- t(summary.tp[,colnames(summary.tp) %in% paths])
for (i in seq_len(nrow(df))) {
df[i,] <- normalize(df[i,])
}
colnames(df) <- summary.tp$enrichment.groupings
pheatmap::pheatmap(df)
pdf("GSEA.heatmapsummary.pdf", height = 10, wisth = 10)
pdf("GSEA.heatmapsummary.pdf", height = 10, width = 10)
pheatmap::pheatmap(df)
dev.off()
SeuratObj <- readRDS(url("https://ncborcherding.github.io/vignettes/Trex_FullExample.rds"))
Trex_vectors <- maTrex(SeuratObj,
chains = "TRA",
AA.properties = "OHE")
library(Trex)
Trex_vectors <- maTrex(SeuratObj,
chains = "TRA",
AA.properties = "OHE")
View(Trex_vectors)
setwd("~/Documents/GitHub/Trex")
sc <- Trex::trex_example
chains = "TRA"
AA.properties = "OHE"
"%!in%" <- Negate("%in%")
"%!in%" <- Negate("%in%")
"%!in%" <- Negate("%in%")
aa.eval <- function(x) { x %in% c("AF", "KF", "other")}
# Add to meta data some of the metrics calculated
#' @importFrom rlang %||%
#' @importFrom SingleCellExperiment colData
add.meta.data <- function(sc, meta, header) {
if (inherits(x=sc, what ="Seurat")) {
col.name <- names(meta) %||% colnames(meta)
sc[[col.name]] <- meta
} else {
rownames <- rownames(colData(sc))
colData(sc) <- cbind(colData(sc),
meta[rownames,])[, union(colnames(colData(sc)),  colnames(meta))]
rownames(colData(sc)) <- rownames
}
return(sc)
}
#Function to pull and organize TCR depending on the chain selected
#' @importFrom stringr str_split
getTCR <- function(sc, chains) {
meta <- grabMeta(sc)
tmp <- data.frame(barcode = rownames(meta),
str_split(meta[,"CTaa"], "_", simplify = TRUE),
str_split(meta[,"CTgene"], "_", simplify = TRUE))
if (length(chains) == 1 && chains != "both") {
if (chains %in% c("TRA", "TRD")) {
pos <- list(c(2,4))
} else if (chains %in% c("TRB", "TRG")) {
pos <- list(c(3,5))
}
} else {
pos <- list(one = c(2,4), two = c(3,5))
ch.1 <- grep("TRB|TRA",sc[[]]$CTgene[1])
chains <- c("TRA", "TRB")
}
TCR <- NULL
for (i in seq_along(pos)) {
sub <- as.data.frame(tmp[,c(1,pos[[i]])])
colnames(sub) <- c("barcode", "cdr3_aa", "genes")
sub$v <- str_split(sub$genes, "[.]", simplify = TRUE)[,1]
sub$j <- str_split(sub$genes, "[.]", simplify = TRUE)[,2]
sub[sub == ""] <- NA
TCR[[i]] <- sub
sub <- NULL
}
names(TCR) <- chains
return(TCR)
}
#This is to grab the metadata from a Seurat or SCE object
#' @importFrom SingleCellExperiment colData
grabMeta <- function(sc) {
if (inherits(x=sc, what ="Seurat")) {
meta <- data.frame(sc[[]], slot(sc, "active.ident"))
if ("cluster" %in% colnames(meta)) {
colnames(meta)[length(meta)] <- "cluster.active.ident"
} else {
colnames(meta)[length(meta)] <- "cluster"
}
}
else if (inherits(x=sc, what ="SingleCellExperiment")){
meta <- data.frame(colData(sc))
rownames(meta) <- sc@colData@rownames
clu <- which(colnames(meta) == "ident")
if ("cluster" %in% colnames(meta)) {
colnames(meta)[clu] <- "cluster.active.idents"
} else {
colnames(meta)[clu] <- "cluster"
}
}
return(meta)
}
#Shhhhhh
quiet <- function(x) {
sink(tempfile())
on.exit(sink())
invisible(force(x))
}
#This is to check the single-cell expression object
checkSingleObject <- function(sc) {
if (!inherits(x=sc, what ="Seurat") &
!inherits(x=sc, what ="SummarizedExperiment")){
stop("Object indicated is not of class 'Seurat' or
'SummarizedExperiment', make sure you are using
the correct data.") }
}
#Returns appropriate model for autoencoder
#' @importFrom tensorflow tf
#' @importFrom keras load_model_hdf5
aa.model.loader <- function(chain, AA.properties) {
quiet(tensorflow::tf$compat$v1$disable_eager_execution())
select  <- system.file("extdata", paste0(chain, "_",
AA.properties, "_Encoder.h5"),
package = "Trex")
model <- quiet(load_model_hdf5(select, compile = FALSE))
return(model)
}
#Selects columns to normalize input data based on the inputs to the model
aa.range.loader <- function(chain, AA.properties, Trex.Data) {
range <- Trex.Data[["model.ranges"]][[chain]]
min <- range[["min"]]
max <- range[["max"]]
ref <- seq(1, 900, 15)
if (AA.properties == "AF") {
ref2 <- sort(c(ref, ref+1, ref+2, ref+3, ref+4))
min <- min[ref2]
max <- max[ref2]
} else if (AA.properties == "KF") {
ref2 <- sort(c(ref+5, ref+6, ref+7, ref+8, ref+9, ref+10, ref+11, ref+12, ref+13, ref+14))
min <- min[ref2]
max <- max[ref2]
}
range <- list(min = min, max = max)
return(range)
}
one.hot.organizer <- function(refer) {
reference <- Trex.Data[[1]]
int <- matrix(ncol = length(reference$aa), nrow = length(refer))
for(i in seq_along(refer)) {
if (is.na(refer[i])) {
next()
}
int[i,which(reference$aa %in% refer[i])] <- 1
}
int[is.na(int)] <- 0
return(int)
}
#Add the eigenvectors to single cell object
#' @importFrom SeuratObject CreateDimReducObject
#' @importFrom SingleCellExperiment reducedDim
adding.DR <- function(sc, reduction, reduction.name) {
if (inherits(sc, "Seurat")) {
DR <- suppressWarnings(CreateDimReducObject(
embeddings = as.matrix(reduction),
loadings = as.matrix(reduction),
projected = as.matrix(reduction),
stdev = rep(0, ncol(reduction)),
key = reduction.name,
jackstraw = NULL,
misc = list()))
sc[[reduction.name]] <- DR
} else if (inherits(sc, "SingleCellExperiment")) {
reducedDim(sc, reduction.name) <- reduction
}
return(sc)
}
AF.col <- c(2,3,4,5,6)
KF.col <- c(7,8,9,10,11,12,13,14,15,16)
#Generates the 30 vector based on autoencoder model
#First normalizes the value by the min and max of the autoencoder training data
auto.embedder <- function(array.reshape, aa.model, local.max, local.min, AA.properties) {
#OHE is already min/max normalized - each aa residue has 1 value and 19 0s
if(AA.properties != "OHE") {
for(i in seq_len(length(array.reshape))) {
(array.reshape[i] - local.min[i])/(local.max[i] - local.min[i])
}
}
array.reshape[is.na(array.reshape)] <- 0
score <- stats::predict(aa.model, t(array.reshape))
return(score)
}
dist.convert <- function(dist_obj, k) {
if (length(k) > 1) stop("The function is not 'vectorized'!")
n <- attr(dist_obj, "Size")
if (k < 1 || k > n) stop("k out of bound!")
##
i <- 1:(k - 1)
j <- rep.int(k, k - 1)
v1 <- dist_obj[f(j, i, dist_obj)]
return(v1)
}
TCR <- getTCR(sc, chains)
library(stringr)
library(keras)
library(reticulate)
TCR <- getTCR(sc, chains)
return <- list() ### Need to add reference data
reference <- Trex.Data[[1]] #AA properties
col.ref <- grep(tolower(paste(AA.properties, collapse = "|")), colnames(reference))
length <- NULL
if (AA.properties == " both") {
column.ref <- unique(sort(c(AF.col, KF.col)))
} else {
column.ref <- unique(sort(col.ref))
}
chain <- names(TCR)
membership <- TCR[[i]]
i <- 1
membership <- TCR[[i]]
names <- membership$barcode
array.reshape <- NULL
aa.model <- quiet(aa.model.loader(chain[[i]], AA.properties))
range <- aa.range.loader(chain[[i]], AA.properties, Trex.Data)
local.min <- range[[1]]
local.max <- range[[2]]
cells <- unique(membership[,"barcode"])
score <- NULL
n <- 1
tmp.CDR <- membership[membership$barcode == cells[n],]$cdr3_aa
refer <- unlist(strsplit(tmp.CDR, ""))
refer <- c(refer, rep(NA, 60 - length(refer)))
int <- one.hot.organizer(refer)
array.reshape.tmp <- array_reshape(int, 1200)
score.tmp <- auto.embedder(array.reshape.tmp, aa.model, local.max, local.min, AA.properties)
aa.model()
select  <- system.file("extdata", paste0(chain, "_",
AA.properties, "_Encoder.h5"),
package = "Trex")
model <- quiet(load_model_hdf5(select, compile = FALSE))
aa.model <- model
score <- stats::predict(aa.model, t(array.reshape))
array.reshape <- array.reshape.tmp
score <- stats::predict(aa.model, t(array.reshape))
View(score)
tfh <- readRDS("./processedData/Fullintegrated_seuratObjects_TFH.rds")
Idents(tfh) <- "tfh_clusters"
tfh$specific <- "No"
tfh$specific <- ifelse(!is.na(tfh$TCRB.epitope) | !is.na(tfh$TCRA.epitope), "Yes", tfh$specific)
table(tfh$specific)
meta <- tfh[[]]
View(meta)
df <- data.frame(tfh@reductions$umap@cell.embeddings, tfh@meta.data)
other <- c("S356.371" ,"S164.179","S815.830", "S800.815", "S356.371", "S657.671","S1101.1115")
df$epitope <- NA
other <- c("S356.371" ,"S164.179","S815.830", "S800.815", "S356.371", "S657.671","S1101.1115")
df$epitope[c(which(df$TCRB.epitope == "S167.180"), which(df$TCRA.epitope == "S167.180"))] <- "epitope.S167.180"
df$epitope[c(which(df$TCRB.epitope %in% other), which(df$TCRA.epitope %in% other))] <- "other.spike"
colors <- ep.colors[c(2,7)]
ep.colors <- viridis_pal(option = "H")(length(epitope))
epitope <- stringr::str_sort(na.omit(unique(df$TCRA.epitope)), numeric = TRUE)
ep.colors <- viridis_pal(option = "H")(length(epitope))
names(ep.colors) <- epitope
colors <- ep.colors[c(2,7)]
names(colors) <- c("epitope.S167.180", "other.spike")
ggplot() +
geom_density2d(data = df, aes(x = UMAP_1, y = UMAP_2), color = "black", lwd = 0.5) +
geom_point(data = subset(df, !is.na(epitope)), aes(x = UMAP_1, y = UMAP_2, fill = epitope), shape=21, stroke = 0.25) +
guides(fill = "none") +
theme_void() +
scale_fill_manual(values = rev(brewer.pal(11, "RdYlBu")[c(2,10)]))
library(RColorBrewer)
ggplot() +
geom_density2d(data = df, aes(x = UMAP_1, y = UMAP_2), color = "black", lwd = 0.5) +
geom_point(data = subset(df, !is.na(epitope)), aes(x = UMAP_1, y = UMAP_2, fill = epitope), shape=21, stroke = 0.25) +
guides(fill = "none") +
theme_void() +
scale_fill_manual(values = rev(brewer.pal(11, "RdYlBu")[c(2,10)]))
table(df$epitope)
table(tfh$specific, tfh$tfh_clusters)
meta <- tfh[[]]
tfh$enrichment.groupings <- NA
tfh$enrichment.groupings[which(meta$tfh_clusters %in% c(1,2))] <- "Memory.TFH"
tfh$enrichment.groupings[which(meta$tfh_clusters %in% c(0,3))] <- "GC.TFH"
tfh$enrichment.groupings[which(meta$tfh_clusters %in% c(7))] <- "C7"
tfh$enrichment.groupings[which(meta$tfh_clusters %in% c(8))] <- "C8"
enrichmentGroups <- unique(tfh$enrichment.groupings)
enrichmentGroups
i <- 1
tmp <- subset(subset.seurat,  enrichment.groupings == enrichmentGroups[i])
tmp <- subset(tfh,  enrichment.groupings == enrichmentGroups[i])
markers <- FindMarkers(tmp,
group.by = "specific",
ident.1 = "Yes",
ident.2 = "No",
test.use = "MAST",
latent.vars = c("donor", "timepoint"),
logfc.threshold = 0,
min.pct = 0,
pseudocount.use = 0.1)
View(markers)
for(i in seq_along(timepoints)) {
tmp <- subset(tfh,  enrichment.groupings == enrichmentGroups[i])
markers <- FindMarkers(tmp,
group.by = "specific",
ident.1 = "Yes",
ident.2 = "No",
test.use = "MAST",
latent.vars = c("donor", "timepoint"),
logfc.threshold = 0,
min.pct = 0,
pseudocount.use = 0.1)
write.csv(markers, paste0("./DGE/timepoint.",enrichmentGroups[i], "_SpikeSpecificvNonspecific.csv"))
}
for(i in seq_along(enrichmentGroups)) {
tmp <- subset(tfh,  enrichment.groupings == enrichmentGroups[i])
markers <- FindMarkers(tmp,
group.by = "specific",
ident.1 = "Yes",
ident.2 = "No",
test.use = "MAST",
latent.vars = c("donor", "timepoint"),
logfc.threshold = 0,
min.pct = 0,
pseudocount.use = 0.1)
write.csv(markers, paste0("./DGE/timepoint.",enrichmentGroups[i], "_SpikeSpecificvNonspecific.csv"))
}
table(tmp$tfh_clusters)
table(tmp$specific)
enrichmentGroups <- na.omit(unique(tfh$enrichment.groupings))
markers <- FindMarkers(tfh,
group.by = "specific",
ident.1 = "Yes",
ident.2 = "No",
test.use = "MAST",
latent.vars = c("donor", "timepoint", "tfh_clusters"),
logfc.threshold = 0,
min.pct = 0,
pseudocount.use = 0.1)
write.csv(markers, paste0("./DGE/Overall_SpikeSpecificvNonspecific_controlBycluster.csv"))
View(markers)
