min <- range[["min"]]
max <- range[["max"]]
ref <- seq(1, 750, 15)
if (AA.properties == "AF") {
ref2 <- sort(c(ref, ref+1, ref+2, ref+3, ref+4))
min <- min[ref2]
max <- max[ref2]
} else if (AA.properties == "AF") {
ref2 <- sort(c(ref+5, ref+6, ref+7, ref+8, ref+9, ref+10, ref+11, ref+12, ref+13, ref+14))
min <- min[ref2]
max <- max[ref2]
}
range <- list(min = min, max = max)
return(range)
}
#Add the eigenvectors to single cell object
#' @importFrom SeuratObject CreateDimReducObject
#' @importFrom SingleCellExperiment reducedDim
adding.DR <- function(sc, reduction, reduction.name) {
if (inherits(sc, "Seurat")) {
DR <- suppressWarnings(CreateDimReducObject(
embeddings = reduction,
loadings = reduction,
projected = reduction,
stdev = rep(0, ncol(reduction)),
key = reduction.name,
jackstraw = NULL,
misc = list()))
sc[[reduction.name]] <- DR
} else if (inherits(sc, "SingleCellExperiment")) {
reducedDim(sc, reduction.name) <- reduction
}
return(sc)
}
AF.col <- c(2,3,4,5,6)
KF.col <- c(7,8,9,10,11,12,13,14,15,16)
#Generates the 30 vector based on autoencoder model
#First normalizes the value by the min and max of the autoencoder training data
auto.embedder <- function(array.reshape, aa.model, local.max, local.min) {
for(i in seq_len(ncol(array.reshape))) {
(array.reshape[,i] - local.min[i])/(local.max[i] - local.min[i])
}
array.reshape[is.na(array.reshape)] <- 0
score <- stats::predict(aa.model, array.reshape)
return(score)
}
#Calculating Distance of AA in CDR3 using mean
#' @importFrom philentropy distance
#' @importFrom keras load_model_hdf5
#' @importFrom reticulate array_reshape
#' @importFrom dplyr bind_rows
aaProperty <- function(TCR,
AA.method = AA.method,
AA.properties = AA.properties,
return.dims = FALSE) {
return <- list() ### Need to add reference data
reference <- Trex.Data[[1]] #AA properties
col.ref <- grep(tolower(paste(AA.properties, collapse = "|")), colnames(reference))
length <- NULL
if (AA.properties == " both") {
column.ref <- unique(sort(c(AF.col, KF.col)))
} else {
column.ref <- unique(sort(col.ref))
}
chain <- names(TCR)
for (i in seq_along(TCR)) {
membership <- TCR[[i]]
names <- membership$barcode
if (AA.method != "auto") {
score <- as.data.frame(matrix(ncol = length(column.ref)+1, nrow = length(unique(membership[,"barcode"]))))
colnames(score) <- c("barcodes", colnames(reference)[column.ref])
score$barcodes <- unique(membership[,"barcode"])
} else {
array.reshape <- NULL
aa.model <- quiet(aa.model.loader(chain[[i]], AA.properties))
range <- aa.range.loader(chain[[i]], AA.properties, Trex.Data)
local.min <- range[[1]]
local.max <- range[[2]]
}
cells <- unique(membership[,"barcode"])
for (n in seq_len(length(cells))) {
tmp.CDR <- membership[membership$barcode == cells[n],]$cdr3_aa
if (AA.method != "auto") {
refer <- unlist(strsplit(tmp.CDR, ""))
int <- reference[match(refer, reference$aa),]
score[n,seq_len(length(col.ref))+1] <- colSums(int[,column.ref])/length(refer)
} else {
refer <- unlist(strsplit(tmp.CDR, ""))
refer <- c(refer, rep(NA, 50 - length(refer)))
int <- reference[match(refer, reference$aa),c(1,col.ref)]
array.reshape.tmp <- array_reshape(as.matrix(int[,-1]), length(col.ref)*50)
array.reshape <- rbind(array.reshape, array.reshape.tmp)
next()
}
}
if (AA.method == "auto") {
#Here is where the autoencoder embeds and returns a 30-vector value for each cdr3
score <- auto.embedder(array.reshape, aa.model, local.max, local.min)
score <- data.frame(unique(membership[,"barcode"]), score)
}
barcodes <- score[,1]
score <- score[,-1]
rownames(score) <- barcodes
colnames(score) <- paste0("aa", seq_len(ncol(score)))
return(score)
}
}
#' either "mean" or the average amino acid characteristics for given cdr3 sequence or "auto"
#' for using an autoencoder model. The autoencoder selection  will not allow for trimming of
#' the cdr3 sequences.
#' @param reduction.name Keyword to save Trex reduction. Useful if you want
#' to try Trex with multiple parameters
#' @param seed seed for the random number generator
#' @export
#' @return Seurat or SingleCellExperiment object with Trex dimensions placed
#' into the dimensional reduction slot.
#'
runTrex <- function(sc,
chains = "TRB",
AA.properties = "AF",
AA.method = "auto",
reduction.name = "Trex",
seed = 42) {
cells.chains <- rownames(sc[[]][!is.na(sc[["CTaa"]]),])
sc <- subset(sc, cells = cells.chains)
reduction <- maTrex(sc,
chains,
AA.properties,
AA.method,
seed)
TCR <- getTCR(sc, chains)
sc <- adding.DR(sc, reduction, reduction.name)
return(sc)
}
data("trex_example")
library(Trex)
data("trex_example")
trex_example <- runTrex(trex_example,
chains = "TRB",
AA.method = "auto",
AA.properties = "KF",
reduction.name = "Trex.KF")
sc <- trex_example
cells.chains <- rownames(sc[[]][!is.na(sc[["CTaa"]]),])
sc <- subset(sc, cells = cells.chains)
chains = "TRB"
AA.properties = "AF"
AA.method = "auto"
reduction.name = "Trex"
cells.chains <- rownames(sc[[]][!is.na(sc[["CTaa"]]),])
sc <- subset(sc, cells = cells.chains)
reduction <- maTrex(sc,
chains,
AA.properties,
AA.method,
seed)
#' either "mean" or the average amino acid characteristics for given cdr3 sequence or "auto"
#' for using an autoencoder model. The autoencoder selection  will not allow for trimming of
#' the cdr3 sequences.
#' @param n.dim The number of Trex dimensions to return, similar to PCA dimensions
#' @param seed seed for the random number generator
#'
#' @export
#' @importFrom SeuratObject CreateDimReducObject
#'
#' @return Trex eigenvectors calculated from multiplex network
maTrex <- function(sc,
chains = "TRB",
AA.properties = "AF",
AA.method = "auto",
seed = 42) {
set.seed(seed)
TCR <- getTCR(sc, chains)
if (AA.properties %in% c("AF", "KF", "both", "all") & !is.null(AA.properties) | !is.null(AA.method)) {
print("Calculating the Amino Acid Properties...")
AA.knn <- aaProperty(TCR, AA.properties)
network <- c(network, AA.knn)
}
barcodes <- rownames(grabMeta(sc))
reduction <- multiplex.network(network, n.dim, barcodes)
return(reduction)
}
reduction <- maTrex(sc,
chains,
AA.properties,
AA.method,
seed)
seed = 42
reduction <- maTrex(sc,
chains,
AA.properties,
AA.method,
seed)
library(stringr)
library(keras)
library(reticulate)
library(dplyr)
reduction <- maTrex(sc,
chains,
AA.properties,
AA.method,
seed)
reference <- Trex.Data[[1]] #AA properties
col.ref <- grep(tolower(paste(AA.properties, collapse = "|")), colnames(reference))
length <- NULL
if (AA.properties == " both") {
column.ref <- unique(sort(c(AF.col, KF.col)))
} else {
column.ref <- unique(sort(col.ref))
}
chain <- names(TCR)
for (i in seq_along(TCR)) {
membership <- TCR[[i]]
names <- membership$barcode
if (AA.method != "auto") {
score <- as.data.frame(matrix(ncol = length(column.ref)+1, nrow = length(unique(membership[,"barcode"]))))
colnames(score) <- c("barcodes", colnames(reference)[column.ref])
score$barcodes <- unique(membership[,"barcode"])
} else {
array.reshape <- NULL
aa.model <- quiet(aa.model.loader(chain[[i]], AA.properties))
range <- aa.range.loader(chain[[i]], AA.properties, Trex.Data)
local.min <- range[[1]]
local.max <- range[[2]]
}
cells <- unique(membership[,"barcode"])
for (n in seq_len(length(cells))) {
tmp.CDR <- membership[membership$barcode == cells[n],]$cdr3_aa
if (AA.method != "auto") {
refer <- unlist(strsplit(tmp.CDR, ""))
int <- reference[match(refer, reference$aa),]
score[n,seq_len(length(col.ref))+1] <- colSums(int[,column.ref])/length(refer)
} else {
refer <- unlist(strsplit(tmp.CDR, ""))
refer <- c(refer, rep(NA, 50 - length(refer)))
int <- reference[match(refer, reference$aa),c(1,col.ref)]
array.reshape.tmp <- array_reshape(as.matrix(int[,-1]), length(col.ref)*50)
array.reshape <- rbind(array.reshape, array.reshape.tmp)
next()
}
}
if (AA.method == "auto") {
#Here is where the autoencoder embeds and returns a 30-vector value for each cdr3
score <- auto.embedder(array.reshape, aa.model, local.max, local.min)
score <- data.frame(unique(membership[,"barcode"]), score)
}
barcodes <- score[,1]
score <- score[,-1]
rownames(score) <- barcodes
colnames(score) <- paste0("aa", seq_len(ncol(score)))
return(score)
}
TCR <- getTCR(sc, chains)
for (i in seq_along(TCR)) {
membership <- TCR[[i]]
names <- membership$barcode
if (AA.method != "auto") {
score <- as.data.frame(matrix(ncol = length(column.ref)+1, nrow = length(unique(membership[,"barcode"]))))
colnames(score) <- c("barcodes", colnames(reference)[column.ref])
score$barcodes <- unique(membership[,"barcode"])
} else {
array.reshape <- NULL
aa.model <- quiet(aa.model.loader(chain[[i]], AA.properties))
range <- aa.range.loader(chain[[i]], AA.properties, Trex.Data)
local.min <- range[[1]]
local.max <- range[[2]]
}
cells <- unique(membership[,"barcode"])
for (n in seq_len(length(cells))) {
tmp.CDR <- membership[membership$barcode == cells[n],]$cdr3_aa
if (AA.method != "auto") {
refer <- unlist(strsplit(tmp.CDR, ""))
int <- reference[match(refer, reference$aa),]
score[n,seq_len(length(col.ref))+1] <- colSums(int[,column.ref])/length(refer)
} else {
refer <- unlist(strsplit(tmp.CDR, ""))
refer <- c(refer, rep(NA, 50 - length(refer)))
int <- reference[match(refer, reference$aa),c(1,col.ref)]
array.reshape.tmp <- array_reshape(as.matrix(int[,-1]), length(col.ref)*50)
array.reshape <- rbind(array.reshape, array.reshape.tmp)
next()
}
}
if (AA.method == "auto") {
#Here is where the autoencoder embeds and returns a 30-vector value for each cdr3
score <- auto.embedder(array.reshape, aa.model, local.max, local.min)
score <- data.frame(unique(membership[,"barcode"]), score)
}
barcodes <- score[,1]
score <- score[,-1]
rownames(score) <- barcodes
colnames(score) <- paste0("aa", seq_len(ncol(score)))
return(score)
}
names(TCR)
setwd("~/Documents/GitHub/Trex")
devtools::document()
devtools::check()
devtools::check()
devtools::check()
library(Trex)
trex_example
trex_example
sc <- trex_example
chains = "TRB"
AA.properties = "AF"
AA.method = "auto"
#Function to pull and organize TCR depending on the chain selected
#' @importFrom stringr str_split
getTCR <- function(sc, chains) {
meta <- grabMeta(sc)
tmp <- data.frame(barcode = rownames(meta),
str_split(meta[,"CTaa"], "_", simplify = TRUE),
str_split(meta[,"CTgene"], "_", simplify = TRUE))
if (length(chains) == 1 && chains != "both") {
if (chains %in% c("TRA", "TRD")) {
pos <- list(c(2,4))
} else if (chains %in% c("TRB", "TRG")) {
pos <- list(c(3,5))
}
} else {
pos <- list(one = c(2,4), two = c(3,5))
ch.1 <- grep("TRB|TRA",sc[[]]$CTgene[1])
chains <- c("TRA", "TRB")
}
TCR <- NULL
for (i in seq_along(pos)) {
sub <- as.data.frame(tmp[,c(1,pos[[i]])])
colnames(sub) <- c("barcode", "cdr3_aa", "genes")
sub$v <- str_split(sub$genes, "[.]", simplify = TRUE)[,1]
sub$j <- str_split(sub$genes, "[.]", simplify = TRUE)[,2]
sub[sub == ""] <- NA
TCR[[i]] <- sub
sub <- NULL
}
names(TCR) <- chains
return(TCR)
}
TCR <- getTCR(sc, chains)
AA.knn <- aaProperty(TCR, AA.properties)
return <- list() ### Need to add reference data
reference <- Trex.Data[[1]] #AA properties
col.ref <- grep(tolower(paste(AA.properties, collapse = "|")), colnames(reference))
length <- NULL
if (AA.properties == " both") {
column.ref <- unique(sort(c(AF.col, KF.col)))
} else {
column.ref <- unique(sort(col.ref))
}
chain <- names(TCR)
i <- 1
membership <- TCR[[i]]
names <- membership$barcode
array.reshape <- NULL
aa.model <- quiet(aa.model.loader(chain[[i]], AA.properties))
range <- aa.range.loader(chain[[i]], AA.properties, Trex.Data)
local.min <- range[[1]]
local.max <- range[[2]]
cells <- unique(membership[,"barcode"])
n <- 1
tmp.CDR <- membership[membership$barcode == cells[n],]$cdr3_aa
tmp.CDR <- membership[membership$barcode == cells[n],]$cdr3_aa
refer <- unlist(strsplit(tmp.CDR, ""))
refer <- c(refer, rep(NA, 50 - length(refer)))
int <- reference[match(refer, reference$aa),c(1,col.ref)]
array.reshape.tmp <- array_reshape(as.matrix(int[,-1]), length(col.ref)*50)
select  <- system.file("extdata", paste0(chain, "_",
AA.properties, "_Encoder.h5"),
package = "Trex")
model <- quiet(load_model_hdf5(select, compile = FALSE))
range <- Trex.Data[["model.ranges"]][[chain]]
View(range)
min <- range[["min"]]
max <- range[["max"]]
ref <- seq(1, 750, 15)
#Here is where the autoencoder embeds and returns a 30-vector value for each cdr3
#score <- auto.embedder(array.reshape, aa.model, local.max, local.min)
x <- auto.embedder(array.reshape,tmp, aa.model, local.max, local.min)
#Generates the 30 vector based on autoencoder model
#First normalizes the value by the min and max of the autoencoder training data
auto.embedder <- function(array.reshape, aa.model, local.max, local.min) {
for(i in seq_len(ncol(array.reshape))) {
(array.reshape[,i] - local.min[i])/(local.max[i] - local.min[i])
}
array.reshape[is.na(array.reshape)] <- 0
score <- stats::predict(aa.model, array.reshape)
return(score)
}
#Here is where the autoencoder embeds and returns a 30-vector value for each cdr3
#score <- auto.embedder(array.reshape, aa.model, local.max, local.min)
x <- auto.embedder(array.reshape,tmp, aa.model, local.max, local.min)
#Here is where the autoencoder embeds and returns a 30-vector value for each cdr3
#score <- auto.embedder(array.reshape, aa.model, local.max, local.min)
x <- auto.embedder(array.reshape.tmp, aa.model, local.max, local.min)
array.reshape <- array.reshape.tmp
for(i in seq_len(ncol(array.reshape))) {
(array.reshape[,i] - local.min[i])/(local.max[i] - local.min[i])
}
for(i in seq_len(length(array.reshape))) {
(array.reshape[,i] - local.min[i])/(local.max[i] - local.min[i])
}
seq_len(length(array.reshape))
for(i in seq_len(ncol(array.reshape))) {
(array.reshape[,i] - local.min[i])/(local.max[i] - local.min[i])
}
for(i in seq_len(length(array.reshape))) {
(array.reshape[,i] - local.min[i])/(local.max[i] - local.min[i])
}
array.reshape[,i]
for(i in seq_len(length(array.reshape))) {
(array.reshape[i] - local.min[i])/(local.max[i] - local.min[i])
}
array.reshape[is.na(array.reshape)] <- 0
score <- stats::predict(aa.model, array.reshape)
array.reshape
score <- stats::predict(aa.model, as.data.frame(array.reshape))
score <- stats::predict(aa.model, data.frame(array.reshape))
score <- stats::predict(aa.model, as.matrix(array.reshape))
score <- stats::predict(aa.model, array.reshape)
class(array.reshape)
score <- stats::predict(aa.model, t(array.reshape))
View(score)
for (n in seq_len(length(cells))) {
tmp.CDR <- membership[membership$barcode == cells[n],]$cdr3_aa
refer <- unlist(strsplit(tmp.CDR, ""))
refer <- c(refer, rep(NA, 50 - length(refer)))
int <- reference[match(refer, reference$aa),c(1,col.ref)]
array.reshape.tmp <- array_reshape(as.matrix(int[,-1]), length(col.ref)*50)
#Here is where the autoencoder embeds and returns a 30-vector value for each cdr3
#score <- auto.embedder(array.reshape, aa.model, local.max, local.min)
score.tmp <- auto.embedder(array.reshape.tmp, aa.model, local.max, local.min)
score <- rbind(score, score.tmp)
}
score <- NULL
#Generates the 30 vector based on autoencoder model
#First normalizes the value by the min and max of the autoencoder training data
auto.embedder <- function(array.reshape, aa.model, local.max, local.min) {
for(i in seq_len(length(array.reshape))) {
(array.reshape[i] - local.min[i])/(local.max[i] - local.min[i])
}
array.reshape[is.na(array.reshape)] <- 0
score <- stats::predict(aa.model, t(array.reshape))
return(score)
}
for (n in seq_len(length(cells))) {
tmp.CDR <- membership[membership$barcode == cells[n],]$cdr3_aa
refer <- unlist(strsplit(tmp.CDR, ""))
refer <- c(refer, rep(NA, 50 - length(refer)))
int <- reference[match(refer, reference$aa),c(1,col.ref)]
array.reshape.tmp <- array_reshape(as.matrix(int[,-1]), length(col.ref)*50)
#Here is where the autoencoder embeds and returns a 30-vector value for each cdr3
#score <- auto.embedder(array.reshape, aa.model, local.max, local.min)
score.tmp <- auto.embedder(array.reshape.tmp, aa.model, local.max, local.min)
score <- rbind(score, score.tmp)
}
View(score)
score <- data.frame(unique(membership[,"barcode"]), score)
View(score)
barcodes <- score[,1]
score <- score[,-1]
rownames(score) <- barcodes
colnames(score) <- paste0("aa", seq_len(ncol(score)))
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
cells.chains <- rownames(sc[[]][!is.na(sc[["CTaa"]]),])
sc <- subset(sc, cells = cells.chains)
reduction <- maTrex(sc,
chains,
AA.properties,)
reduction <- maTrex(sc,
chains,
AA.properties)
devtools::check()
View(reduction)
DR <- suppressWarnings(CreateDimReducObject(
embeddings = reduction,
loadings = reduction,
projected = reduction,
stdev = rep(0, ncol(reduction)),
key = reduction.name,
jackstraw = NULL,
misc = list()))
reduction.name = "Trex.KF"
DR <- suppressWarnings(CreateDimReducObject(
embeddings = reduction,
loadings = reduction,
projected = reduction,
stdev = rep(0, ncol(reduction)),
key = reduction.name,
jackstraw = NULL,
misc = list()))
DR <- suppressWarnings(CreateDimReducObject(
embeddings = as.matrix(reduction),
loadings = as.matrix(reduction),
projected = as.matrix(reduction),
stdev = rep(0, ncol(reduction)),
key = reduction.name,
jackstraw = NULL,
misc = list()))
devtools::check()
devtools::check()
devtools::check()
devtools::install()
